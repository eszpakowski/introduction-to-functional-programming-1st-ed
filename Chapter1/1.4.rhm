#lang rhombus

// 1.4.1 -----
// definite_integral :: (num -> num) -> (num -> (num -> num))

// 1.4.2 -----
// (num -> num) -> num
fun apply_zero(f :: Number -> Number) :: Number:
  f(0)

check:
  apply_zero(fun(n): n * n)
  ~is 0

// num -> (num -> num)
fun adder(n :: Number) :: Number -> Number:
  fun(m): n + m

check adder(1)(3) ~is 4
  
// (num -> num) -> (num -> num)
fun apply_and_multiply(f :: Number -> Number) :: Number -> Number:
  fun(n): f(n) * n

check:
  apply_and_multiply(fun(n): n * n)(3)
  ~is 27

// 1.4.3 -----
// sign :: num -> num
fun sign(n :: Number) :: Int:
  cond
  | (n > 0): 1
  | (n < 0): -1
  | ~else: 0

check:
  sign(-128) ~is -1
  sign(200) ~is 1
  sign(0) ~is 0

// 1.4.4 -----
// one :: α -> num
fun one(x):
  1

// apply :: (α -> β) -> (α -> β)
fun apply(f):
  fun(x): f(x)

check:
  apply(fun(x): x * x)(3)
  ~is 9

// compose :: ((α, β) -> γ) -> (α -> (β -> γ))
fun compose(f):
  fun(g):
    fun(x): f(g, x)

check:
  compose(fun(x, y): x + y)(4)(6)
  ~is 10
